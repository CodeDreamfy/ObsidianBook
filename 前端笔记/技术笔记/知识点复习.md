#Vue #JavaScript #面试题

#### 简单说一下什么是虚拟Dom，什么是Diff算法？

虚拟Dom不是vue最先提到的，之所以有虚拟dom，是因为vue是以数据驱动视图显示页面，但是当一个页面的变量或者控制因素达到几百个以上的时候，本来直接操作真实dom的开销就很大，反复操作dom会让系统开销变的更大，加上随时依赖变更就会导致更新，严重影响框架的性能，因此虚拟dom的提出就是为了解决这个问题的，虚拟dom不是真正意义上的dom，他只是对真实dom的抽象表达，为的是当我们更新了数据后，通过新旧vnode对比，以实现最小化更新dom的能力。它是以javascript对象的形式存在的，并且每个对象都对应了一个真真实的dom节点，这个对象包含了节点的类型，属性，事件等信息。而diff算法是新旧虚拟dom进行对比的算法，为了提升比对的效率诞生的，diff算法可以将两个虚拟dom进行对比，然后记录差异部分，最后将差异部分更新到真实dom上，vue可以将整个操作在放在了内存上面进行操作，从而提升了性能。
而diff算法的原理是：diff算法是在patch函数中实现的。
1. 创建vnode：在vue中虚拟dom树的创建主要是通过解析模板或渲染函数得到的。vue编译期将模板转换为渲染函数，该函数在组件实例被渲染的时候调用，返回虚拟dom节点，这些vnode都是js对象，表示真实dom的属性和结构
2. diff入口：vue更新过程中，通过调用`_update`函数触发虚拟dom更新，其内部会调用`_patch_`函数，这是diff算法的入口
3. 创建新的dom节点：在patch函数内部，会先进行一些判断，比如是否是首次渲染，则会调用createElm函数创建新dom节点。createElm函数会递归遍历新的虚拟dom树，根据虚拟dom节点的类型创建对应的dom节点，并将其插入到父节点中。
4. 比较新旧虚拟dom树：在patch函数内部，如果不是首次渲染，会调用`patchVnode`函数进行新旧dom比较，`patchVnode`会比较节点的标签类型、属性和事件等，如果有差异，会相应更新真实dom节点的属性和内容
5. 对列表渲染的额优化，列表有唯一的key，可通过`updateChildren`函数进行优化比较过程。会比对新旧key来判断节点的复用，插入和删除的
6. 更新子节点：在`patchVnode`函数内部，如果发现节点需要更新，会进一步递归更新子节点，整个虚拟dom树会被深度优先遍历，逐个比较更新。

diff算法的详细流程：
1. 比较根结点的，如果不同就替换整棵树
2. 类型相同就比较属性差异
3. 对比子节点使用双指针技巧：
	1. oldStart/newStart指向新旧节点开始的位置
	2. oldEnd/newEnd指向新旧节点结束的位置
	3. 每次比较oldStart和newStart和oldEnd和newEnd
	4. 不同的话就表示需要删除和新增

**虚拟dom的更新时机是什么？**
vue是响应式系统驱动，当vue组件的数据发生变化时，会触发虚拟dom更新，总的来说，虚拟dom更新时机有以下几种情况：
1. 手动调用$forceUpdate，Vue会立即触发虚拟Dom的更新过程
2. 响应式变化：Vue的响应式系统会自动追踪组件中的响应式数据变化。当响应式数据发生改变时，Vue 会触发虚拟dom的自动更新过程
3. 异步更新队列：处理一系列数据变化的时候，Vue会将这些变化自动合并，并通过异步更新队列批量处理。只有在下一个事件循环中，才会触发虚拟dom

当vue数据发生数据变化时：
1. vue追踪数据变化，当数据发生变化的时候，标记相应组件为“脏”状态
2. 将组件添加到更新队列：将标记为“脏”状态的组件添加到异步更新队列
3. 等待下一个事件循环：vue会利用js的事件循环机制，在下一个事件循环中执行更新操作。可以将多个数据变化合并，并一次性执行更新操作，减少重复计算和渲染过程
4. 执行更新：下一个事件循环中，vue会遍历更新队列中的组件，并执行虚拟dom的更新操作，包括diff算法，比较新旧dom树的差异，并更新实际dom树


#### vue2的虚拟dom和vue3的区别什么是什么呢？
1. 静态树优化：vue3中，编译器会明确标记出静态树，在diff过程中，静态树会被直接跳过，不需要进行比较。
2. 静态节点优化：如果节点是静态的，并且父节点也是静态的，那么这个节点不会被单独创建，而是直接使用父节点，减少了js代码并提高了渲染性能
3. 引入了Fragment：一个组件可以有多个根节点，vue中只能有一个根节点
4. 模版编译优化：vue3中，编译器会生成更有效的代码，只针对可能发生变化的部分进行更新。


#### 什么是事件循环？事件循环优先级是什么？
事件循环是js中一种用于处理异步操作的执行机制。负责处理js代码，浏览器api的回调函数以及其他事件的调度和执行顺序。
基本原理如下：
1. 按照顺序执行，遇到异步操作
2. 异步操作被注册：遇到异步操作如定时器，网络请求时候，被注册，并在指定时间或者事件触发的时候，放入相应的任务队列
3. 任务队列：js维护多个任务队列，如宏任务和微任务。宏任务用于存放较大的任务，如定时器回调、dom事件回调等。微任务用于存放较小的任务，如promise回调，MutationObserver等
4. 执行顺序：事件循环每一轮，js引擎会先处理微任务队列中的所有任务，然后再处理宏任务，微任务优先级高于宏任务
5. 循环：事件循环不断重复上述过程，处理任务队列，直到所有队列为空
6. nodejs中的稍有差异：
	1. nodejs中宏任务和微任务都包含了一些异步任务，但其中微任务会优先于宏任务执行
	2. node触发时机由I/O操作和定时器等异步任务完成情况决定的
	3. setTimeout和setInterval的精度：浏览器有偏差，但是在node中触发时机相对更准确，具有更高精度
	4. promise.resolve().then 高于process.nextTick优先级

**宏任务和微任务的区别：**
宏任务一般是由浏览器提供的任务源，包括事件回调、异步操作（定时器、ajax请求、dom事件）、渲染等
执行时机：宏任务会被放入宏任务队列，每一次事件循环只会执行一个宏任务。
优先级：宏任务优先级低于微任务，每一轮事件循环中，宏任务执行前，都会先执行所有微任务
常见的宏任务有：setTimeout、setInterval、I/O、Dom事件
微任务：
由js提供任务源，通常通过Promise、MutationObserver等方式注册的回调函数
执行时机：微任务会被放入微任务队列
优先级：微任务优先级高于宏任务
常见微任务：Promise回调、MulationObserver回调等
执行顺序示例：

1. 执行一个宏任务。
2. 在宏任务执行过程中，如果产生了微任务，将它们添加到微任务队列。
3. 宏任务执行完毕后，检查是否有微任务队列。如果有，依次执行微任务队列中的微任务。
4. 当前事件循环结束。
5. 开始下一个事件循环，重复以上步骤。

需要注意的是，在同一轮事件循环中，宏任务可能会添加新的宏任务，而微任务只会在当前轮次中执行。因此，当宏任务不断添加时，可能会导致微任务一直被推迟执行，从而导致事件循环时间较长。



#### JavaScript垃圾回收机制是什么样的?
javascript在创建变量的时候自动分配内存，并在不使用的时候“自动”释放。
一般内存的生命周期是：1. 分配所需要的内存 2. 使用分配的内存（读/写）3. 不需要时进行释放
**垃圾回收** 
一般分为两种：1. 引用计数垃圾收集 。2. 标记-清除

> MDN: 
	最初的垃圾回收机制依赖于引用的概念：对象有没有被其他对象引用到，如果是0引用则进行垃圾回收
	但是无法解决循环引用，比如一个使用一个div存储了htmlDocument元素，然后让整个div.xx某个属性引用该dom对象，那么就会造成循环引用，这时候会认为它们彼此相互有一次引用，所以无法清除。
	2012年后现代浏览器都使用了标记清除法，这个算法假定设置一个根root的对象，垃圾回收机制将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
  
JavaScript 的垃圾回收机制主要是通过一种叫做标记清除（Mark-and-Sweep）的算法来实现的。JavaScript 的这种自动垃圾回收机制使得开发者可以创建和使用对象而不需要关心对象的内存管理和回收。下面就来详细介绍一下这个过程。

##### 标记清除（Mark-and-Sweep）

1. **标记阶段**：这个阶段中，垃圾回收器从根（在 JS 中，根是全局对象）开始查找，遍历所有可达对象，每找到一个对象，就给对象添加一个标记。从根开始的变量称为根。其它所有的都会从根开始进行可达性检查。
2. **清除阶段**：清除阶段开始后，垃圾回收器会遍历所有对象，清除掉那些在标记阶段中没有被标记的对象。同时会移除所有已经被清理掉对象的标记。

##### 引用计数（Reference Counting）
其核心思想是跟踪每一个值被引用的次数。当声明一个变量并将一个引用类型值赋给该变量时候，这个值的引用次数就是1，以此类推。

引用计数是另一种垃圾回收策略，但在现代浏览器中并不常用，因为它有一个很大的问题是无法解决循环引用。在这种策略中，如果一个对象的引用次数为0，那么这个对象就会被认为是"垃圾"，并被回收。

##### 延迟清除和增量清除

为了避免在进行垃圾回收时导致程序的停顿，一些现代 JavaScript 引擎使用了延迟清除和增量清除的策略。在延迟清除中，垃圾回收器将清除操作推迟到程序空闲时。在增量清除中，垃圾回收器将清除操作分解为多个小任务，并在一段时间内逐步完成这些任务。

##### 分代回收

JavaScript的垃圾回收器还会使用分代回收的策略。这种策略基于一个事实，那就是许多对象一旦创建，它们的生命周期都很短。因此，JavaScript的垃圾回收器将内存分为两个或更多的"代"，并分别对这些"代"进行清理。新创建的对象被放在一个代中，而经过几次垃圾回收仍然存活的对象被移到另一个代中。

需要注意的是，不同的JavaScript引擎可能会采用不同的策略和优化来进行垃圾回收，但大致的原理都是一样的，就是找出那些不再需要的对象，并回收它们所占用的内存

#### JavaScript事件触发顺序是什么样的？什么是捕获什么是冒泡？
1. 捕获阶段：当用户触发一个元素事件时，浏览器会从根节点通常是document开始，逐层向下传递目标元素，这个过程中，浏览器会检查沿途每一个元素是否对该事件注册了捕获处理函数，如果有则触发。
2. 目标阶段：事件传递到实际触发事件的元素上，会触发目标元素的事件处理函数
3. 冒泡阶段：事件从目标元素开始，逐层向上传递到根节点。这个过程中，浏览器会检查沿途的每个元素是否对事件注册了冒泡处理函数，如果有责触发该函数
4. 可以使用event.stopPropagation阻止事件捕获或者冒泡。而event.preventDefault则是用来阻止元素默认行为，如阻止默认链接的默认点击行为
5. 当监听事件的时候，第三个参数为true或者capture为true会在捕获阶段处理事件，否则在冒泡阶段处理
6. 事件捕获或者冒泡的作用可以在事件委托中体现，当大量子节点需要监听同一种类型的事件时候，可以通过在父节点监听事件来处理所有子节点

#### 什么是闭包，闭包有什么应用？
当函数可以记住并访问所在的词法作用域时就产生了闭包。闭包是一种避免被垃圾回收机制销毁的手段，多应用于函数内部需要返回另一个函数，存储临时参数等，比如函数柯里化等
对闭包的解释补充：
1. 闭包可以通过返回内部函数的方式实现在外部访问函数的变量达到记住外部变量的目的
2. 闭包的关键是它延伸了变量的作用范围，正常情况下，函数执行完后局部变量会被销毁，但通过闭包可以让变量一直存活在内存中
闭包的应用：
1. 封装数据和隐藏实现细节
2. 保持数据的持久性，函数柯里化，事件监听，ajax请求等需要维持状态的函数
3. 闭包有导致内存泄漏的风险，要注意解除无用的闭包引用


#### 什么是原型，什么是原型链
原型只和函数和实例对象有关联。
每个对象都有一个__proto__被成为原型，该原型指向了构造该对象的引用，原型的作用是用来实现继承，当在一个对象上调用某个属性或者方法时候未能找到的时候会顺着原型往上查找，一直查找到根节点null
每一个函数都有一个prototype的属性，该属性有一个constructor的属性指向了函数本身，prototype可以存储一些属性或者方法让所有实例对象调用，也可以将prototype指向另一个函数的实例对象，这样该函数的实例就可以调用另一个函数的原型方法了，依此类推，形成了链，被称为原型链

以下是Claude.ai的回答
1. 原型(prototype)是函数独有的属性,它指向了一个对象。该对象为构造函数创建的实例对象的原型对象。
2. 每个实例对象都有一个内部指针__proto__指向创建它的构造函数的原型对象,可以通过__proto__沿着原型链找属性和方法。
3. 原型链是由原型对象相互关联而构成的链条结构。如果一个对象的属性或者方法不存在,会顺着其原型对象的__proto__往上查找,直到找到或查到null为止。
4. 函数的prototype属性指向了一个对象,这个对象就是调用该构造函数创建实例时,该实例的原型对象。
5. 通过构造函数的prototype对象可以实现继承,子类的prototype可以指向父类的一个实例,这样子类就可以继承父类的属性和方法。

以下是ChatGPT的回答
1. 原型（Prototype）：每个对象（除了 null）都有一个 `__proto__` 属性，它指向了构造该对象的构造函数的原型对象。原型对象是一个普通的对象，可以包含属性和方法。通过原型，对象可以继承并共享原型对象中的属性和方法。在 JavaScript 中，对象的原型可以通过 `Object.getPrototypeOf(obj)` 或 `obj.__proto__` 来访问。
    
2. 原型链（Prototype Chain）：当在一个对象上访问属性或方法时，如果对象本身没有该属性或方法，JavaScript 引擎会沿着对象的原型链向上查找，直到找到该属性或方法或者达到原型链的顶端（即 `null`）。原型链的顶端通常是 `Object.prototype`，即所有对象的原型对象。通过原型链，对象可以通过继承和委托的方式访问父级对象的属性和方法。
    
3. 函数的原型对象（prototype）：每个函数对象都有一个 `prototype` 属性，它是一个普通对象。函数的 `prototype` 对象中可以添加属性和方法，这些属性和方法可以被该函数的实例对象继承。例如，当通过 `new` 关键字创建一个实例对象时，该实例对象的 `__proto__` 属性会指向函数的 `prototype` 对象。
    

需要注意的是，原型链是由对象的 `__proto__` 属性组成的链式结构，它的形成是由对象和构造函数之间的关联所决定。原型链的查找是从下往上的，如果在原型链上找不到所需的属性或方法，则返回 `undefined`。

另外，JavaScript 中还有一个 `constructor` 属性，它指向构造函数本身。通过 `constructor` 属性，可以追溯回原型链中对象的构造函数。


#### 箭头函数的特点是什么？
1. 相对普通函数语法更加简洁
2. 没有自己的this绑定
3. 没有arguments对象
4. 不能用作构造函数，因为它没有自己的this
5. 不能使用yield关键字
6. 不能通过call、apply、和bind改变this指向

#### 什么是作用域，什么是作用域链，什么是上下文？
1. 作用域指的是变量或函数的可访问范围,即声明变量或函数时所在的代码区域。 JavaScript采用的是词法作用域,函数的作用域在函数定义时就决定了。
2. 作用域链是由当前执行上下文的变量对象组成的一个链表结构,用于变量查找。查找时会先在当前作用域查找,如果没有找到就会向上级作用域继续查找,直到找到全局作用域。
3. 执行上下文是评估和执行 JavaScript 代码的环境,它包含了变量对象、this引用等信息。每个函数调用都会创建一个新的执行上下文。
4. 当调用函数时,会创建一个执行上下文,并将其添加到执行上下文栈中。函数的执行上下文包含了函数的作用域链,因此作用域链是连接执行上下文和作用域的桥梁。

总结:作用域控制变量访问,作用域链在多个作用域间建立变量查找关系,执行上下文提供代码执行环境并包含作用域链。三者关系密不可分。


#### vue2和vue3的差别是什么？简单讲讲

1. 组合式API：提供了更灵活更容易抽离的组合式API来组织和封装代码的方式
2. 从webpack迁移到了vite，编译速度和热加载速度变的更快
3. 使用Proxy代理对象替代了Vue2中的Object.defineProperty来实现响应式数据追踪
4. 更好的typescript的支持，提供了更好的类型推导、类型定义和编辑器的支持
5. 引入了Teleport组件，提供了一种更灵活的组件渲染方式
6. Fragment组件，允许模板中使用多个根节点从而无需额外的包裹元素
7. 更好的Tree-shaking支持

#### pinia是如何做到存储状态的，被任意地方调用都存在呢？
每一个通过调用defineStore创建的状态实际上是创建了一个新的Pinia实例，并将其与该状态模块相关联

#### 简单讲讲vue的use的应用，什么时候需要使用呢？抽离组件需要注意什么？
Vue中的Composition API - use的几点使用场景:

1. 逻辑复用:将通用逻辑提取到use函数中,在多个组件中复用。
2. 提取状态ful逻辑:将组件内状态ful的逻辑提取到use函数中。
3. 副作用逻辑提取:如数据获取,DOM操作等副作用逻辑可以提取到use中。
4. 自定义hook:封装常用功能为自定义hook,实现抽象化。
5. 减少模板代码:在setup中使用use,减少模板代码量。

使用use提取组件逻辑需要注意:

1. 单一功能原则:每个use function只做一件事。
2. 明确use接口:use函数要暴露清晰的接口给组件使用。
3. 减少副作用:避免use中过多副作用逻辑,会降低可读性。
4. Hook复用:适当地重构使hook更具通用性,方便复用。
5. 状态管理:大量状态时可以结合Pinia做集中管理。

总之,合理地使用use可以提高代码的可维护性和复用性

#### 简单讲讲前端权限要如何设计？

1. 通过用户角色来过滤菜单(前端方式控制)，路由在前端配置，通过API返回角色过滤
2. 通过后台来动态生成路由表(后台方式控制)
3. 通过后台返回所有权限集合（包括菜单和按钮），前端固定路由，进行过滤
RABC定义权限

#### Promise和async/await的区别是什么
以下基于claudeAI回答：
1. Promise 是一种对象,表示一个异步操作的最终完成或失败,而 async/await 是一种语法,基于 Promise 实现的。
2. Promise 主要用于处理 then 链,解决回调地狱问题;async/await 通过同步的方式编写异步代码,增强可读性。
3. async/await 使得异步代码看起来像同步代码,而 Promise 保留了异步代码的写法。
4. async/await 会隐式创建一个 Promise,并且返回它,而 Promise 是显式创建的。
5. async/await 使得链式调用更简单,通过同步方式实现链式调用。
6. async/await 需要适当的错误处理,而 Promise 中国会通过回调方式处理错误。
7. async/await 避免了 Promise 一些复杂的状态管理
---
1. async/await的提案最初确实是基于generator实现的。
2. 但后来TC39决定将async/await直接建立在promise的基础上,而不是generator。
3. async函数会隐式返回一个promise对象,await会等待这个promise完成。
4. generator需要执行器如co模块来驱动,而promise与async/await是语言层面支持的。
5. promise的出现是让generator方案有了更好的基础,async/await继承了这一优势。
6. 所以async/awaitMiddleware比直接使用generator更符合语言层面的实现,也更简洁易用。


#### 如何匹配括号？

#### 简单阐述一下快速排序的原理，以及和冒泡排序的区别？

快速排序的实现原理可以分为以下几步:

1. 1. 选择基准元素：从数组中选择一个基准元素。通常可以选择数组的第一个元素、最后一个元素或者随机选择一个元素作为基准。
    
2. 分割数组：将数组中的其他元素与基准元素进行比较，将小于等于基准元素的元素放到基准元素的左边，将大于等于基准元素的元素放到基准元素的右边。此时，基准元素所处的位置就是它最终的排序位置。
    
3. 递归排序：对基准元素左边和右边的子数组进行递归排序。重复上述步骤，直到子数组的大小为 0 或 1，此时子数组已经有序。
    
4. 合并结果：通过递归排序得到的有序子数组，将左边的子数组、基准元素和右边的子数组合并起来，形成最终的有序数组。

快速排序的时间复杂度平均为 O(nlogn),最坏情况下会退化为 O(n^2)。但通常快速排序都要比其他简单排序算法快很多。

快速排序是一个原地排序算法,空间复杂度只有 O(logn)。它通过递归调用解决了排序问题,是一个十分高效的排序算法。
- 对于大数据集,快速排序速度更快,是首选排序算法。
- 对于小数据集,冒泡排序代码较简单,也可以使用
- 快速排序平均时间复杂度为O(nlogn),最坏为O(n^2)
- 冒泡排序时间复杂度为O(n^2)
- 快速排序使用递归分治法,通过partition分区函数对数组进行分割。
- 冒泡排序通过交换相邻元素实现排序。
  
冒泡排序是一种简单的排序算法，它的基本思想是通过不断交换相邻元素的位置，将最大（或最小）的元素逐渐“冒泡”到正确的位置。

冒泡排序的过程如下：

1. 从数组的第一个元素开始，比较相邻的两个元素。如果前面的元素大于后面的元素，就交换它们的位置。
    
2. 继续对每一对相邻的元素进行比较和交换，直到最后一个元素。这样一轮比较和交换后，最大（或最小）的元素将“冒泡”到数组的末尾。
    
3. 重复上述步骤，但是每次比较和交换的次数都减少一次，因为在每一轮中，最大（或最小）的元素已经被确定在了正确的位置。
    
4. 重复进行上述步骤，直到所有元素都排好序。
```javascript
function bubbleSort(arr) {
  const n = arr.length;
  for (let i = 0; i < n - 1; i++) {
    for (let j = 0; j < n - i - 1; j++) {
      // 比较相邻的两个元素
      if (arr[j] > arr[j + 1]) {
        // 交换位置
        const temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
  }
  return arr;
}

// 示例用法
const array = [64, 34, 25, 12, 22, 11, 90];
const sortedArray = bubbleSort(array);
console.log(sortedArray); // [11, 12, 22, 25, 34, 64, 90]

```


#### JavaScript的基本类型是什么
JavaScript是一门动态弱类型的语言

动态，是因为他的值和任何类型都无法强关联，比如定义一个变量为字符串，然后又可以将其赋值为数字

弱类型，当操作涉及不匹配的类型时，类型可以进行隐式的转换而不是报错

什么是原始值？

除了Object外，所有类型都定义了表示在语言最底层面的**不可变**值，称这些值为原始值。

所谓不可变：一旦创建了原始值，不能被更改，尽管持有它的变量可以被重新赋值。相比数组和对象，它们的属性和元素可以在不重新分配新值的情况下更改。

除了Null和undefined，其他的原始类型都有其包装类型

原始值有：

- Null
- Undefined
- Boolean
- String
- Number
- BigInt
- Symbol

### Undefined

undefined表示没有任何值，null表示没有任何对象，没有值的时候默认返回undefined

- 没有值return的语句，隐式返回undefined
- 访问不存在的对象属性，返回undefined
- 变量声明没有原始值，隐式初始化为undefined
- 许多api比如find、get等方法没有发现元素时候，返回undefined

null是关键字，而undefined是一个普通标识符，全局属性。因此undefind不应被遮蔽。

Prototype

对象都有一个__proto__的原型属性，但这只是真正的原型的getter/setting方法

F.prototype仅用在new F被调用时使用，它为新对象[[prototype]]赋值

每个函数都有一个prototype的常规属性，即使我们没有提供。

默认的prototype是一个只有属性constructor的对象。属性constructor指向函数自身

正常情况下，constructor属性可以通过[[Prototype]]给所有实例使用

关于constructor：javascript自身不能确保正确的`constructor`函数值

原生的原型

原型获取方式，目前不推荐使用__proto__，改为使用：

- Object.getPrototypeOf(obj) — 返回对象obj的[[prototype]]
- Object.setPrototypeOf(obj,proto) — 将对象obj的[[prototype]]设置为proto
- Object.create(proto, [descriptors]) — 利用给定的proto作为[[prototype]]和可选的属性来创建一个空对象

```jsx
let animal = { eats: true }
let rabbit = Object.create(animal); // 与 {__proto__: animal } 相同
```

`**__proto__` 不是对象的属性，而是Object.prototype的访问器属性，因此，`__proto__` 是一种访问[[Prototype]]的方式，而不是[[Prototype]]本身**

1. Vue3相对于Vue2有哪些重大变化？
    1. 从使用webpack构建变成使用vite，es-module的方式，使得页面在开发阶段编译更快，打包体积更小，效率更高
    2. 语法上面变化较大，新出的Composition API方式组织代码，使得代码组织变得更加灵活，封装特定功能或者组件变得更加容易
    3. 声明周期改变，vue3新增了setup的生命周期，去掉了created的周期等
    4. 之前单文件的根结点必须唯一，现在单页面的template上面可以存在多个根节点，其原理是根据Framement文档片段来的
    5. 多个v-model绑定，setup语法等等
    6. 响应式的方式由get，set变为Proxy的实现
    7. 更好的支持了typescript
2. Vue3中的Composition API是什么？它如何不同于Vue2中的Options API？
    1. 所谓Composition API实际上是vue3新推出的组合式API方式构建代码
    2. 允许按照逻辑相关性而不是Options选项类型来组织代码
    3. 更易于组件封装，OptionsAPI中，组件选项散落不同属性中，而CompositionAPI则将相关所有逻辑代码封装在一块，使得组件的可读性更高
    4. 更好的类型推导和更好的复用性
    5. 实际开发中：
        1. 功能模块化，按照逻辑将某一些逻辑进行拆分和组装
        2. vue2中使用混入mixins导致组件不好调试，不知道哪里在调用，但是在CompositionAPI中，由于useXXX灵活性可以更好的复用给特定组件
3. Vue3中的Teleport和Suspense组件是什么？请举例说明它们的用法。
    1. Teleport是指可以将Temeport包裹的组件传送至指定dom节点去渲染，比如当我们需要一个全局弹层的时候，又不想破坏原有页面结构，可以通过Teleport进行实现，这样就可以使用fixed
    2. Suspense是一个组件树中协调内部有异步依赖的处理的组件，可以让组件树中上层组件等待下层的多个嵌套异步依赖项解析完成，并可以等待时渲染一个加载状态
4. Vue3中的v-model指令有哪些变化？如何使用v-model实现自定义双向绑定逻辑？
    1. v-mode可以用于自定义组件，并且同一组件可以使用多个
    2. 使用v-model实现双向绑定：在一个组件上面，v-model等价于:value=”xxx”,然后在其内部需要加上@on(’upload:value’, xxx)
    3. 另一种实现方式是使用计算属性实现一种可以写的getting和setting
5. Vue3中的Reactivity API是什么？请解释响应式系统的工作原理。
    1. 所谓Reactivity API是Vue3使用新的ES特性Proxy来实现的
    2. 响应式系统工作原理：每一个变量创建的时候无论是通过ref，还是reactive，其都是通过new Proxy构造了一个新的代理对象去监听其内部的值的变化，最后将这个代理对象返回给用户
6. Vue3中的Setup函数是什么？它的作用是什么？如何使用它？
    1. setup函数是Composition API的入口，Vue3规定了CompositionAPI必须写在setup中
    2. setup中没有this，如果是选项式的setup不可以使用箭头函数来定义
7. Vue3中的动态组件和异步组件有何不同？如何使用它们？
    1. 动态组件是通过is实现的，此时组件只是不确定是哪一个
    2. 而异步组件则是通过动态import来动态导入的，只有在执行到的那一刻才会去加载它
8. Vue3中的模板和渲染函数有何不同？什么时候应该使用渲染函数？
    1. 模版更加直观，更利于编程，而渲染函数则是通过renderAPI来进行动态创建渲染的，需要熟悉相应的API的参数配置，相对来说更加难一些
    2. 在封装一些特定组件，比如table的时候，有时候slot无法满足，用户可能需要自定义一些界面，可以通过暴露render函数，让用户传入vnode进行定制化开发
9. Vue3中的provide和inject API是什么？它们的作用是什么？如何使用它们？
    1. 这两个API分别是提供和注入的api，一般是配套使用的，可以通过这两个API将根组件定义提供的属性或者方法注入或者传递给对应的子组件或者嵌套组件接收
10. Vue3中的全局API有哪些？包括如何创建全局组件、指令和插件等。
    1. 比如defineProps、defineComponent、createApp、defineAsyncComponent、getCurrentInstance、isRef等等API

1. 您提到在IFRS17项目中，通过重构原有技术栈，使项目与后端松耦合解绑，更加方便前端开发过程中的调试。请简要说明一下您是如何实现前后端松耦合的。
    
    1. 原有项目使用了前后端未分离版本的若依系统，首先找到一个分离版本的若依前端版本，然后将原来vue2的多页应用集成进来，删除对应的入口文件，然后重新配置路由，使用动态路由方式，此时需要从后端增加针对前端路由的接口，然后进行二次渲染，但是遇到的难点是，分离版的若依所使用的后端api及接口调用方式全部更改，此时只能采取将项目上有关系统方面的页面仍然使用后端老的若依进行提供，通过iframe进行操作，但是由于已经前后端分离开了，需要一个新的标记来识别哪些是需要走iframe的等等
    2. 封装了日志查看通用组件，因为17存在大量多个地方的用户导入，因此需要在每个导入口进行查看导入的具体详情日志，精准到哪一行缺什么字段等等，
    3. 封装了table
    4. 通过理解需求，与产品沟通，项目上所有的页面都是由前端把控的，大部分的ui统一交互方式，及一些需求不明确的页面也是由我设计的
    5. 单一职责及约定俗成
2. 在WarRoom AP项目中，您提到解决了卡片连线的拐点问题。请说明一下您采用的最短路径算法的具体实现方法。
    
    1. 之前的连线采用的是两个坐标点直接连线的，为了路演且使得显示更美观，通过查资料采用了基于图论的flyoh算法来计算最短路径的坐标，然后通过向量判断箭头方向实现连线
3. 在DService项目中，您提到使用SSR技术进行服务端渲染，并通过Node.js将后端接口二次封装转到前端。请介绍一下您是如何实现服务端渲染和前后端接口的交互的。node端
    
4. 请介绍一下您在前端开发方面的经验和技能。
    
    近几年主要中后台开发较多，比较擅长前端基础项目搭建，Vue开发，同时熟悉w3c标准，css新特性，Javascript新语法，同时也较为了解unix系统，docker部署等
    
5. 您在项目中使用过哪些前端框架和技术？可以详细描述一下您对其中一种技术或框架的理解和应用经验吗？
    
    在项目中使用Vue2较多，Vue2是一种mvvm的架构，其本身只提供了vm的功能，由用户提供model和view层的实现，从vue的发展中可以看到vue从形而大的前端框架变得越来越独立，目前就只保留了vue-core核心，让用户在开发中更灵活的可以使用更多可替代的非核心插件，如pinia状态管理，或者i18n等，将这些业务用到的功能性组件独立出去，使得vue更加轻量化，更加符合松耦合和单一职责。也方便开发者方便的将vue应用到不同场景下的业务中。
    
6. 在您的工作经历中，您遇到过的最具挑战性的技术问题是什么，您是如何解决的？
    
    最近一次遇到的最具挑战的工作是接手别人的代码进行二次开发，要求实现卡片的直角连线，最开始思路是获取两个图的坐标然后使用svg进行连线，然后取中间点可调整，然后通过查找资料，最后使用了最短路径算法，用向量来判断连线的方向，使用图论，通过计算节点各个点之间的最短距离，找到从起点到终点的最优路径。通过基于图的遍历和动态规划的思想，通过逐步更新节点之间的距离值，最终找到最短路径。
    
7. 您如何保持对新技术和前端发展的关注？您最近学习或尝试过哪些新技术或工具？
    
    一般主要会去逛逛GitHuh、Twitter、关注一些技术牛人，还有看一看周刊，看一看相关公众号和技术博客，遇到新东西或者感兴趣的会去写demo去了解一下具体的应用场景，看适不适用于当下或者以后的业务，做一做技术储备
    
8. 您在团队中扮演过项目负责人的角色，请分享一次您成功领导团队完成项目的经验。
    
    在17项目中作为前端负责人，当时遇到一次BD打单的需求，因为着急给客户演示，然后又需要临时出一个之前系统没有的功能，因此我首先明确这个功能的具体需求以及截止时间，然后通过和组内其他前端沟通，让大家明白此次需求的节点和每个人需要负责的部分，然后根据团队成员的专长合理分配任务，过程中不断的跟进成员的进度以及遇到问题提供必要的支持和资源，如在开发某个具体需求可能存在歧义或者觉得有矛盾点，立马拉来产品进行沟通及时梳理和确认需求，最后通过不懈的努力并且预留了时间给测试，完成了此次BD打单需求的任务。
    
9. 在项目开发过程中，您是如何与设计师和后端开发人员进行沟通和协作的？
    
    因为我们采用的是敏捷开发，一个迭代为两周，每个迭代结束前会开这个迭代的验收和总结会议，然后接着开下个迭代要准备做的事情，在需求分析会上，会大致沟通一下设计应该要注意的点，比如前端组件可以实现的可以不用过度设计，和后端沟通中一般会提前确定好接口提交方式，以及可能需要它们提供的数据。在实际开发中当进行连调的时候如果有条件会进行面对面调试，节约不必要的沟通成本。
    
10. 请介绍一次您在前端开发中遇到的性能优化挑战，并分享您的解决方案。
    
    在项目中主要遇到的性能优化挑战主要是接口请求较多以及重复请求很多，我是这样做优化的：
    
    1. 进行接口缓存，对于重复请求的接口，利用缓存机制进行优化，使用相同的接口在本地缓存中获得响应
    2. 请求合并，将多个接口和后端协商更改为单一接口一次性获取
    3. 在axios进行请求去重的处理，将请求的url和参数进行存储，判断是否存在相同请求在进行，如果是则取消重复请求。
    
    除了接口请求优化以外还有页面加载的问题，主要是打包出来的bundlejs过大的问题，首先通过包分析的插件进行分析，看哪些依赖较大，然后通过重新配置webpack的打包策略或者vite的打包策略，将公共资源进行合并和压缩，然后各个页面的js进行按需加载，然后利用浏览器缓存，设置合适的缓存策略和缓存头。最后一点是进行代码审查，在开发中使用merge request的方式，代码合并之前先进行Review
    
11. 您有使用过前端工程化工具吗？例如，可以描述一下您使用过的构建工具、代码规范工具和自动化测试工具等。
    
    使用过webpack和vite，webpack需要自己去定义loader和如何打包代码，他有入口和出口的配置，也有静态资源的配置，其实vite也差不多，只是vite是基于es-module的特性进行编译和打包的，会在项目中配置eslint+prettier+standarjs，然后加上postcss的autoprefix等，如果有必要可能还有less和sass，提交会使用husky进行预提交的commit备注校验
    
12. 在您的工作经历中，有没有遇到过项目进度紧张或任务优先级冲突的情况？您是如何处理的？
    
    会有多个项目突然碰到一起的情况，当遇到多个项目都很着急的时候，会首先和领导沟通哪个优先级相对较高，看是否需要加人或者根据优先级来处理工作。
    
13. 您如何保持代码的质量和规范？在团队中推动代码质量的控制和改进有哪些实践经验？
    
    代码上使用了eslint和prettier等进行约束，然后迭代会上会showcode，进行review


1. CSS:
    - 可否描述一下BFC(Block Formatting Context)，它有什么作用，以及如何创建一个BFC？
        
        BFC是块级格式化上下文的意思，主要作用是用来解决布局时候一些margin无法重合或者浮动塌陷等问题，当一个元素设置了overflow、display、position等属性的时候会创建一个BFC
        
    - 请解释下CSS中的继承和层叠规则是如何工作的？
        
        继承是只针对一些css属性如果不主动设置值那么其属性会自动去取其父级甚至更远节点的组件对应的值，比如说font相关的属性会继承
        
        层叠指的是给当前元素如果设置了值，那么如果此时通过其父元素点选到该元素设置了另一个值，那么此时会计算其从父节点到当前节点的累加权重值进行对比，看谁的优先级更高
        
    - 描述一下CSS动画和CSS过渡的区别及使用场景。
        
        css动画无需触发，只要加上class或者设置好就可以主动执行，而过渡必须要通过触发的形式才能执行，两者的使用场景有一些差异，比如说当hover到一个元素上想要让其有一个渐变的效果可以通过过渡，而当加载一个页面想让页面显示的更友好需要一个loading时就需要使用animation
        
    - 请谈谈CSS预处理器（如SASS, LESS等）的优缺点，你通常如何使用它们？
        
        css预处理器的优点是可以定义变量，方法和mixin等功能性css，方便更快的编写css和节约重复写css的工作，提高效率
        
        缺点是开发的时候需要配置好编译less或者sass的引擎或者loader，因为这些特定的语言特性无法直接被解析需要经过编译后成为css才能被浏览器所识别
        
        通常我会使用less或者sass其中的一种，甚至会使用postcss这种后处理器，将一些公共css的公共属性抽离到一个特定的mixin中，还有一些公共的css效果，比如文本省略，三角形，滚动条等这些公共css抽到特定的变量中，然后需要的时候只需要include就好了
        
    - 哪些CSS属性会导致重排（reflow）或重绘（repaint），如何优化？
        
        会导致重排的css属性有：margin，padding，display，positon等
        
        会导致重绘的css属性有：background，color等
    2. JavaScript:
    - 请谈谈JavaScript中的执行上下文和作用域链，以及这两者之间的关系？
        
        js执行上下文：js执行前会先进行预编译，将一些变量和函数提前声明，这样在使用的时候即使在定义前调用了函数或者属性仍然可以正常执行。函数在执行的时候，可以访问到其当前所在域的上下文环境中所有的变量或者函数
        
        所谓作用域链就是当在一个函数内部有另一个函数时候，内部函数调用了某一个变量，但是其内部并没有，此时就会沿着作用域链进行往上查找
        
        执行上下文和作用域连是两个东西一个是在当前作用域进行查找一个是依次往外层进行查找
        
    - 可否解释一下JavaScript中的事件循环（Event Loop）以及“宏任务”（macro-task）和“微任务”（micro-task）？
        
        javascript的事件循环主要有setTimeout，setInterval， promise等来实现，当调用setTimeout时候会将该事件添加到宏任务中，而promise则是在微任务中
        
    - 解释一下**`Promise`**，**`async/await`**和**`Generator`**之间的关系和区别。
        
        Promise和async/await ，Generator都是可以进行异步加载数据的API，其中async/await是generator的语法糖，而Promise则是基于宏任务来执行的
        
    - 可否描述一下JavaScript中的内存泄露，以及你是如何预防和解决内存泄露问题的？
        
        当代码出现死循环，或者判断条件无法终止的情况下会导致内存泄漏，一般预防内存泄露主要的方式是1.使用ts，进行严格类型校验，2.写测试用例和循环或者递归的时候一定要加上阀值
        
    - 如何理解JavaScript中的“原型链”？如何通过原型链实现继承？
        
        每一个对象都有一个__proto__被称为原型，其原型有一个constructor指向了该对象自身，而每个函数也都有一个属性叫prototype，这个属性也有一个constructor指向了函数自身，当我们访问数组实例的某个方法的时候，实际上是通过_proto__来进行查找调用其某个方法。
        
        要想实现继承，可以将原型指向另一个函数，这样就可以在当前函数访问一个不存在的属性或者方法的时候会继续往上查找形成了原型链
        
        1. CSS: ◦ **BFC**：块格式化上下文（Block Formatting Context）是Web页面的可视化CSS渲染的一部分，它是块级盒布局发生的区域，也是浮动元素与其他元素的交互限定区域。BFC在布局、浮动、阻止margin重叠等方面有重要应用。我们可以通过设置元素的CSS属性来创建BFC，例如设定**`overflow`**不为**`visible`**，设定**`display`**为**`table-cell`**、**`table-caption`**和**`inline-block`**，或者设定**`float`**为**`left`**或**`right`**。 ◦ **CSS中的继承和层叠规则**：继承是某些CSS属性的一种特性，子元素可以继承其父元素的某些样式。层叠是指当多个CSS规则应用于同一个元素时，浏览器如何决定使用哪个规则的过程，决定因素包括源顺序、特定性和重要性。 ◦ **CSS动画和CSS过渡的区别及使用场景**：CSS过渡是在元素从一种样式逐渐改变为另一种样式时添加过渡效果，常用于:hover伪类。CSS动画则是从一组样式列表中逐步切换，常用于实现复杂的动态效果。 ◦ **CSS预处理器**：CSS预处理器如SASS和LESS等允许开发者使用变量、嵌套规则、混合（Mixin）、函数等高级功能来编写CSS。它们的优点包括增强了CSS的可重用性、可维护性，缺点是需要预编译环境，增加了开发配置复杂性。 ◦ **CSS重排和重绘**：当改变元素的几何属性（如宽度、高度等）时，浏览器需要重新计算元素的位置，触发重排。当改变元素的颜色、背景等视觉样式时，浏览器需要重绘元素。优化策略包括批量修改样式、使用**`transform`**替代几何属性等。
            
        2. JavaScript:  **执行上下文和作用域链**：执行上下文是JS代码被评估和执行的环境，每个执行上下文都有一个关联的变量环境，用来存储变量和函数声明。作用域链是由当前执行上下文的变量环境和所有父级变量环境组成的链表结构，JS引擎在查找变量时会沿着作用域链逐级查找。 ◦ **事件循环，宏任务和微任务**：JS采用事件循环（Event Loop）处理异步任务，每个事件循环中包含一个或多个宏任务和微任务。宏任务包括script、setTimeout、setInterval等，微任务包括Promise、MutationObserver等。在每个宏任务执行后，会执行所有的微任务。 ◦ **Promise，async/await和Generator**：Promise是JS处理异步操作的对象，通过.then或者.catch进行链式调用。async/await是基于Promise的语法糖，使异步代码的写法更像同步代码。Generator则是JS的一种特殊函数类型，可以用于编写可控制的异步流程。 ◦ **JS内存泄露**：JS内存泄漏指的是不再需要的内存没有被垃圾回收器回收，常见的情况包括全局变量、计时器或回调函数的误用等。预防内存泄漏的策略包括及时清理不再使用的对象、函数和监听器等。 ◦ **JS原型链和继承**：在JS中，每个对象都有一个指向其原型（prototype）的内部链接（**proto**），而原型对象上又有一个constructor属性指向与之关联的构造函数，通过这个链表结构，JS实现了对象和原型的继承关系。常见的继承方式有原型链继承、构造函数继承和组合继承等。
            
        3. CSS:
            
            - 请谈谈你如何理解CSS中的优先级规则，比如说！important，行内样式，ID，类，元素等是如何影响CSS样式优先级的？
            - 你是如何理解和使用CSS中的伪类和伪元素的？它们有什么区别？
            - 能不能谈谈你对响应式设计的理解？你是如何进行响应式设计的？
        4. JavaScript:
            
            - 请详细说明JavaScript中的事件冒泡和事件捕获，以及如何使用stopPropagation和preventDefault。
            - 能不能解释一下JavaScript中的深拷贝和浅拷贝？如何实现深拷贝？
  
            - 你是如何理解和使用JavaScript的模块系统（ES6模块，CommonJS）的？
